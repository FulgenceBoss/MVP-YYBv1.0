# DOCUMENT DE RÉFÉRENCE - DÉVELOPPEMENT MVP YESSI-YESSI
# Mis à jour le: 16/06/2025

---

### STACK TECHNIQUE
- **Frontend :** React Native (Expo SDK 51+), Redux Toolkit, React Navigation, Axios.
- **Backend :** Node.js, Express.js, Mongoose, JWT, bcryptjs, `node-cron`.
- **Base de données :** MongoDB (via MongoDB Atlas).
- **Sécurité :** `helmet`, `express-rate-limit`, validation des entrées.

---

### DOCUMENTATION DES API

#### API Endpoint: `POST /api/auth/register`
- **Description:** Enregistre un nouvel utilisateur et envoie un code OTP (simulé).
- **Fichier Contrôleur:** `backend/controllers/authController.js` (fonction `registerUser`)
- **Protection:** Publique, avec limitation de débit.
- **Corps de la requête :**
  ```json
  { "fullName": "John Doe", "phoneNumber": "061234567", "pin": "1234" }
  ```
- **Réponse (Succès - 201 Created):** `{"success": true, "message": "Utilisateur enregistré..."}`
- **Réponses (Erreur):** `400` (Données invalides, utilisateur existant), `500` (Erreur serveur).

#### API Endpoint: `POST /api/auth/verify-otp`
- **Description:** Vérifie un code OTP pour finaliser l'inscription et renvoie un token JWT.
- **Fichier Contrôleur:** `backend/controllers/authController.js` (fonction `verifyOtp`)
- **Protection:** Publique.
- **Corps de la requête :**
  ```json
  { "phoneNumber": "061234567", "otpCode": "987654" }
  ```
- **Réponse (Succès - 200 OK):** `{"success": true, "token": "[JWT_TOKEN]"}`
- **Réponses (Erreur):** `400` (Utilisateur non trouvé, OTP invalide/expiré).

#### API Endpoint: `POST /api/auth/login`
- **Description:** Connecte un utilisateur existant et renvoie un token JWT.
- **Fichier Contrôleur:** `backend/controllers/authController.js` (fonction `loginUser`)
- **Protection:** Publique, avec limitation de débit.
- **Corps de la requête :**
  ```json
  { "phoneNumber": "061234567", "pin": "1234" }
  ```
- **Réponse (Succès - 200 OK):** `{"success": true, "token": "[JWT_TOKEN]"}`
- **Réponses (Erreur):** `400` (Identifiants incorrects, utilisateur non trouvé).

---

### FONCTIONNALITÉS IMPLÉMENTÉES (Refonte Majeure)

- **Refonte Complète du Flux d'Accueil :**
  - L'ancien parcours a été remplacé par un flux plus psychologique et intuitif : `GoalSelectionScreen` -> `SpeedSelectionScreen` -> `ConfirmationScreen`.
  - **`GoalSelectionScreen` :**
    - Permet à l'utilisateur de choisir un objectif prédéfini parmi une grille visuelle ou de créer le sien.
    - Utilise un modal (`CustomGoalModal`) pour la création/modification d'objectifs personnalisés (nom + montant).
    - Logique de navigation intelligente qui gère le retour au `Dashboard` pour un utilisateur existant.
  - **`SpeedSelectionScreen` :**
    - Récupère l'objectif choisi et affiche un récapitulatif.
    - Propose des "vitesses" d'épargne claires et permet la saisie d'un montant personnalisé via un modal (`CustomAmountModal`).
    - Intègre des composants réutilisables (`TimeSelector`, `MobileMoneySelector`) pour une expérience cohérente.
    - Affiche un récapitulatif complet et dynamique (incluant le temps estimé pour atteindre l'objectif).
    - Implémente un feedback de chargement clair sur le bouton d'activation.
  - **`ConfirmationScreen` :**
    - Célèbre la fin de la configuration avec une animation Lottie.

- **Synchronisation Backend/Frontend :**
  - Le modèle de données `SavingsConfig` a été mis à jour pour inclure la nouvelle structure (`goal` et `dailyAmount`).
  - Le `savingsController` a été corrigé pour sauvegarder et renvoyer les bonnes données.
  - Le calcul du `streak` (série de jours) est maintenant implémenté côté backend.

- **Amélioration du `DashboardScreen` :**
  - Affiche désormais correctement le nom de l'objectif, son montant, et l'épargne quotidienne.
  - Le calcul de la barre de progression est synchronisé avec l'objectif réel de l'utilisateur.
  - Le bouton "Modifier" ouvre un modal pour un changement rapide de la vitesse d'épargne, avec un lien pour modifier l'objectif.
  - La section "Prochain palier" est maintenant dynamique.

- **Nettoyage du Code :**
  - Les anciens écrans (`AmountSelectionScreen.js`, `FinalConfigScreen.js`) ont été supprimés.
  - Le navigateur (`AppNavigator.js`) a été nettoyé.

---

### ÉTAT ACTUEL DU DÉVELOPPEMENT (Point de reprise)

- **Objectif Actuel :** Finaliser l'implémentation de la fonctionnalité "Profil Utilisateur".
- **Progrès Récents :** Le socle backend est complet et validé. Les fondations du frontend (écrans, state management) sont posées. La gestion des erreurs de connexion a été améliorée pour afficher des messages clairs.
- **Point de Blocage / Difficulté :**
  - **Nature du Problème :** Une erreur de réseau persistante (`ERR_NETWORK`) empêche l'application mobile (sur l'émulateur/téléphone) de communiquer avec le serveur backend qui tourne sur le PC.
  - **Cause Identifiée :** L'application tente d'atteindre le serveur via son adresse IP sur le réseau local (ex: `192.168.1.67`), mais la connexion échoue. Cela peut être dû à plusieurs facteurs : un pare-feu (Windows/antivirus) qui bloque le port `8080`, ou des configurations réseau spécifiques qui empêchent la communication entre l'appareil mobile et le PC sur le même réseau Wi-Fi.
  - **Ce qui a été tenté :** Le passage de `localhost` à l'adresse IP locale, puis l'utilisation de `npx expo start --tunnel` ont échoué à cause des restrictions du réseau Wi-Fi de l'hôtel, empêchant la connexion entre le téléphone et le serveur de développement local.
- **Prochaine Action :**
  1.  **Résoudre le problème de connectivité réseau :**
      - **Vérification du Pare-feu :** S'assurer que le pare-feu de Windows ou de tout logiciel de sécurité autorise les connexions entrantes sur le port `8080` pour le processus Node.js.
      - **Test de connectivité simple :** Essayer d'accéder à l'adresse `http://VOTRE_IP:8080/` depuis le navigateur web du téléphone mobile. Si la page "API is running..." ne s'affiche pas, le problème est bien lié au réseau et non à l'application.
  2.  **Une fois la connexion rétablie,** finaliser la **Phase 3** en rendant les écrans de profil et de paramètres entièrement dynamiques, puis passer à la **Phase 4** pour implémenter les actions (modification du nom, du PIN, etc.).

---

### STRATÉGIE DE DÉPLOIEMENT POUR LE DÉVELOPPEMENT

- **Contexte :** Face aux problèmes de connectivité réseau persistants qui empêchent le bon fonctionnement du duo "Expo Go + Serveur Local", une nouvelle stratégie a été adoptée pour garantir un environnement de développement stable et fiable.
- **Solution Mise en Place :**
  1.  **Backend Déployé sur Render :** Le serveur backend a été déployé sur la plateforme Render. Il est maintenant accessible publiquement et de manière stable via l'URL `https://yessi-yessi-backend.onrender.com`. Cela élimine tous les problèmes liés au réseau local, aux pare-feux et aux adresses IP.
  2.  **Build de Développement (APK) :** Au lieu d'utiliser l'application Expo Go (qui nécessite une connexion directe au PC), nous construisons un APK de développement dédié via le service EAS Build (`eas build`). Cet APK embarque tout le code JavaScript, le rendant autonome. Il n'a plus besoin de se connecter au serveur de développement sur le PC et peut communiquer directement avec le backend sur Render.

### ÉTAT ACTUEL DU PROJET (Point de reprise)

- **Objectif Immédiat :** Valider le bon fonctionnement de l'application avec la nouvelle architecture de déploiement.
- **Action en Cours :** La construction de l'APK de développement a été lancée avec la commande `eas build --profile development --platform android` dans le dossier `frontend/`.
- **Prochaine Action à la Reprise :**
  1.  **Télécharger et Installer l'APK :** Une fois le build terminé, suivre le lien fourni par EAS pour télécharger et installer le fichier APK sur le téléphone de test.
  2.  **Effectuer les Tests de Validation Critiques :**
      - **Test 1 (Nouvel Utilisateur) :** Créer un compte de A à Z et s'assurer que l'activation de l'épargne fonctionne sans erreur "Not authorized".
      - **Test 2 (Utilisateur Existant) :** Se connecter et accéder à l'écran de profil pour vérifier qu'il n'y a plus d'écran noir ou de crash.
  3.  **Une fois la validation réussie,** nous pourrons enfin reprendre le développement des fonctionnalités en attaquant la **Phase 3** (rendre les écrans de profil et de paramètres dynamiques).

---

### NOUVEAU WORKFLOW DE DÉVELOPPEMENT QUOTIDIEN

- **Contexte:** Le déploiement sur Render et l'utilisation d'un APK de développement modifient notre manière de travailler. Voici le nouveau processus à suivre.

- **Pour modifier le BACKEND :**
  1.  **Coder en Local :** Modifiez les fichiers dans le dossier `backend` sur votre PC comme d'habitude.
  2.  **Tester en Local (Optionnel) :** Vous pouvez toujours lancer votre serveur localement (`node server.js`) pour des tests rapides.
  3.  **Déployer les Changements :** Pour que les changements soient effectifs pour votre application mobile, faites un `git commit` puis un `git push`. Render détectera le push et mettra à jour le serveur en ligne automatiquement en quelques minutes.

- **Pour modifier le FRONTEND :**
  1.  **Coder en Local :** Modifiez les fichiers dans le dossier `frontend` sur votre PC.
  2.  **Tester les Changements :**
      - **Pour les petits changements (texte, couleurs, logique simple) :** Après avoir sauvegardé vos fichiers, il suffit de **redémarrer l'application** sur votre téléphone (la fermer depuis le gestionnaire d'applications, puis la rouvrir). L'APK de développement va automatiquement télécharger les dernières modifications JavaScript. **Vous n'avez PAS besoin de reconstruire l'APK.**
      - **Pour les gros changements (ajout de nouvelles librairies, modification de la configuration native) :** Vous devrez reconstruire un nouvel APK avec la commande `eas build --profile development --platform android` (lancée depuis le dossier `frontend/`).
  3.  **Règle simple :** Essayez toujours de simplement redémarrer l'application d'abord. Si cela ne fonctionne pas ou si vous avez ajouté un nouveau paquet, alors seulement lancez un nouveau build.

---

### CONFIGURATIONS SPÉCIFIQUES AU DÉVELOPPEMENT

- **Accès au Serveur Backend via le Réseau Local :**
  - **Contexte :** Pour permettre à l'application mobile (lancée avec `npx expo start --tunnel`) de communiquer avec le serveur backend Node.js sur le PC de développement, le serveur doit accepter les connexions externes.
  - **Changement Appliqué :** Dans le fichier `backend/server.js`, la ligne `app.listen(PORT)` a été modifiée en `app.listen(PORT, "0.0.0.0")`.
  - **Justification :** Le `0.0.0.0` indique au serveur d'écouter sur toutes les interfaces réseau disponibles, et pas seulement sur `localhost`. C'est ce qui permet au tunnel Expo de fonctionner.
  - **NOTE POUR LA PRODUCTION :** Cette configuration est **strictement réservée au développement local**. En production, le serveur applicatif doit être placé derrière un reverse proxy (ex: Nginx) pour des raisons de sécurité, et la configuration d'écoute devra être adaptée en conséquence.

---

### DETTE TECHNIQUE ET ACTIONS POST-MVP

- **Nettoyage de l'Historique Git (Priorité Haute) :**
  - **Contexte :** Pour débloquer le développement, un push contenant le fichier `google-services.json` (et donc des clés secrètes) a été manuellement autorisé sur GitHub.
  - **Risque :** Le secret est maintenant présent dans l'historique du dépôt. Bien que le risque soit limité pour ce projet, c'est une mauvaise pratique de sécurité.
  - **Action Requise :** Après le MVP, il faudra suivre une procédure de nettoyage de l'historique (ex: avec `git filter-repo` ou `BFG Repo-Cleaner`) pour supprimer définitivement le fichier secret de tous les commits. Il faudra ensuite invalider et remplacer les clés compromises sur la console Google Firebase.

---

### FONCTIONNALITÉS EN ATTENTE / AMÉLIORATIONS FUTURES

- **Réactiver et Fiabiliser le Calcul du "Streak" :**
  - **Contexte :** La logique de calcul des jours d'épargne d'affilée (`streak`) dans `savingsController.js` s'est avérée complexe et renvoyait des résultats incorrects.
  - **État Actuel :** La fonctionnalité a été temporairement désactivée (logique commentée dans le backend, affichage commenté dans le frontend) pour ne pas présenter une information erronée à l'utilisateur.
  - **Action Requise :** Il faudra allouer une session de développement dédiée pour :
    1.  Déboguer en profondeur la logique de comparaison des dates des transactions.
    2.  Écrire des tests unitaires (si possible) pour valider le calcul dans différents scénarios (jours consécutifs, jours manquants, etc.).
    3.  Une fois la logique fiabilisée, réactiver l'affichage sur le `DashboardScreen`.

- **Finaliser la Sélection d'Avatar (Dette Technique) :**
  - **Contexte :** Après avoir résolu les problèmes de crash du backend, la fonctionnalité d'upload d'avatar est maintenant confrontée à un nouveau problème côté client : un clic sur l'avatar dans l'écran de profil ne déclenche aucune action (la galerie d'images ne s'ouvre pas).
  - **État Actuel (Ce qui est en place) :**
    - **Frontend :**
      - La librairie `expo-image-picker` est installée et configurée.
      - La fonction `pickImage` dans `ProfileScreen.js` est correctement liée au bouton de l'avatar.
      - La logique de demande de permission (`requestMediaLibraryPermissionsAsync`) est présente.
      - L'action Redux `updateUserAvatar` dans `userSlice.js` est prête à traiter et envoyer l'image sélectionnée.
    - **Backend :**
      - L'endpoint `PUT /api/users/me/avatar` est entièrement fonctionnel, testé et prêt à recevoir une image via `multer`, la traiter et la téléverser sur Cloudinary.
  - **Action Requise (Pour plus tard) :**
    1.  Déboguer la fonction `pickImage` dans `frontend/src/screens/user/ProfileScreen.js`.
    2.  Utiliser la méthode des "logs numérotés" pour vérifier si l'appel à `ImagePicker.launchImageLibraryAsync` est bien atteint et pour inspecter sa réponse.
    3.  Vérifier la gestion des permissions sur l'appareil de test (il est possible qu'une permission ait été refusée de manière permanente).
    4.  S'assurer que la version de `expo-image-picker` est bien compatible avec le reste de l'environnement de build (EAS).

---

### NOTES DE DÉVELOPPEMENT : APPROCHE POUR LES NOTIFICATIONS (TÂCHE #9)

- **Objectif Stratégique :**
  1.  **Créer la confiance :** Confirmer que l'épargne a bien eu lieu.
  2.  **Motiver l'utilisateur :** Lui rappeler ses objectifs et célébrer ses succès.
  3.  **Rendre l'application vivante :** Maintenir une connexion avec l'utilisateur même quand l'application est fermée.

- **Approche Globale en 5 Phases :**
  - **Phase 1 : La Fondation (Côté Client) :** Obtenir la permission de l'utilisateur et son token de notification Expo.
  - **Phase 2 : La Machinerie (Côté Serveur) :** Créer la capacité technique d'envoyer une notification à un token spécifique.
  - **Phase 3 : La Première Notification (Test) :** Envoyer une notification de confirmation immédiate après une épargne manuelle réussie.
  - **Phase 4 : Les Notifications Programmées (CRON) :** Mettre en place les rappels et confirmations pour l'épargne automatique.
  - **Phase 5 : La Finition (Contrôle et Navigation) :** Permettre à l'utilisateur de gérer ses préférences de notification et implémenter le "deep linking".

---

### JOURNAL DES PROBLÈMES RÉSOLUS

- **Échec Silencieux de l'Inscription/Connexion :** Un débogage approfondi a révélé plusieurs problèmes en cascade :
  1.  **Cause Initiale :** Une mauvaise configuration de l'URL de l'API dans le code client (`192.168.1.81` au lieu de `192.168.1.74`).
  2.  **Cause Profonde :** Un bug dans le `authSlice` de Redux où les reducers `setLoading` et `setError` n'étaient pas définis, provoquant un gel de l'application au moment du `dispatch`.
- **`ERR_NETWORK` au Login :** Ce problème était un "faux positif" causé par le gel de l'application dû au bug Redux. La connectivité réseau était en réalité fonctionnelle. Il a été définitivement résolu en corrigeant l'adresse IP de l'API dans `frontend/src/api/config.js`.
- **Instabilité du Serveur Backend :** La tâche CRON s'exécutait toutes les minutes et entrait en conflit avec les requêtes de l'API, bloquant le processus Node.js. **Solution :** Les tâches CRON sont maintenant désactivées en mode développement.
- **Avertissement `VirtualizedLists` sur le Dashboard :** Le `ScrollView` a été remplacé par une `FlatList` avec un `ListHeaderComponent` pour une performance et une structure optimales.
- **Erreur `Unable to resolve module react-native-svg` :** Un problème persistant qui a résisté aux méthodes de nettoyage de cache classiques.
  1.  **Hypothèse Initiale (Incorrecte) :** Problème de cache de Metro Bundler ou de `npm`.
  2.  **Cause Réelle :** Installation d'une version de `react-native-svg` incompatible avec le SDK Expo du projet, due à l'utilisation de `npm install` au lieu de la commande propriétaire d'Expo.
  3.  **Solution Définitive :** Désinstallation de la librairie (`npm uninstall`) et réinstallation avec la commande correcte qui garantit la compatibilité : `npx expo install react-native-svg`.
- **Conflit de dépendances `react-native-svg` (Erreur "register two views") :**
  - **Symptôme :** L'application plante au démarrage avec une longue liste d'erreurs "Invariant Violation: Tried to register two views with the same name RNSVG...".
  - **Cause :** La librairie `react-native-svg` est initialisée deux fois, créant un conflit. Cela se produit souvent à cause de versions conflictuelles des dépendances dans `node_modules`.
  - **Solution (Robuste) :** Effectuer un nettoyage complet de l'environnement de développement.
    1.  Fermer tous les terminaux et éditeurs de code.
    2.  Supprimer manuellement les dossiers `node_modules` à la racine du projet et dans le dossier `frontend`. (Sur Windows, si l'accès est refusé, un redémarrage de l'ordinateur peut être nécessaire pour libérer les fichiers).
    3.  Exécuter `npm install` à la racine pour réinstaller proprement toutes les dépendances.
    4.  Lancer l'application avec `npx expo start -c` pour s'assurer que le cache est propre.
- **...et de nombreux autres problèmes de configuration et de logique résolus lors de cette session de débogage intensive.**
- **Logique de redirection des nouveaux utilisateurs :**
  - **Symptôme :** Les nouveaux utilisateurs étaient redirigés vers le `Dashboard` au lieu du flux de configuration de l'épargne.
  - **Cause :** La logique du composant `
  - **Cascade d'erreurs de compilation (Build Android) :** Une série de problèmes a empêché la compilation du "development build".
  1.  **Erreur `Default FirebaseApp is not initialized` :**
      - **Symptôme :** L'application plantait après la demande de permission de notification.
      - **Cause :** Le fichier `google-services.json` n'était pas inclus dans le build, car il manquait la référence dans la configuration Expo.
      - **Solution :** Ajout de la clé `"googleServicesFile": "./google-services.json"` dans la section `android` du fichier `app.json`.
  2.  **Erreur `The expo package was not found` :**
      - **Symptôme :** La commande `npx eas build` échouait systématiquement car elle ne trouvait pas l'exécutable `expo`.
      - **Cause :** Le projet contient deux `package.json` (un à la racine `YYB/` et un dans `frontend/`). Les commandes étaient lancées depuis la racine au lieu du dossier `frontend`, qui contient les bonnes dépendances.
      - **Solution :** Exécuter systématiquement toutes les commandes `npm` et `eas` depuis le dossier `frontend/`. Pour fiabiliser, un script `eas-build:dev` a été ajouté au `package.json` du frontend.
  3.  **Erreur Gradle `Missing project_info object` :**
      - **Symptôme :** La compilation sur les serveurs d'EAS échouait lors du traitement du fichier `google-services.json`.
      - **Cause :** Le fichier avait été téléversé via une méthode incorrecte et obsolète (`eas credentials` -> `FCM Legacy Key`), ce qui a corrompu son format.
      - **Solution :** La clé incorrecte a été supprimée. Le fichier `google-services.json` a été téléversé de manière sécurisée via la méthode moderne (`npx eas secret:create ... --type file`). Le fichier `eas.json` a été mis à jour pour lier ce secret à la variable d'environnement `GOOGLE_SERVICES_JSON` lors de la compilation.

---

### NOUVEAU FLUX D'ACCUEIL UTILISATEUR (À IMPLÉMENTER)

- **Contexte :** Le flux d'accueil initial (`Inscription -> Choix Montant -> Config Finale`) a été jugé peu engageant. Un nouveau flux, plus centré sur la motivation de l'utilisateur, a été validé et son implémentation a commencé.
- **Objectif :** Remplacer l'ancien flux par un parcours plus psychologique pour améliorer l'activation et la rétention des nouveaux utilisateurs.

- **Nouveau Flux Cible Validé :**
  `Inscription -> Choix Objectif -> Choix Vitesse (Montant) -> Config Finale (sur la même page) -> Célébration -> Dashboard`

---

### PRINCIPES CLÉS DE LA REFONTE

#### Fluidifier la Configuration Finale
- **Observation actuelle :** L'utilisateur passe de `AmountSelectionScreen` à `FinalConfigScreen`, ce qui crée une étape supplémentaire.
- **Conseil :** Une fois le montant sélectionné, au lieu de naviguer vers un nouvel écran, faites apparaître les deux dernières questions directement en dessous sur la même page : "À quelle heure ?" et "Quel portefeuille ?". Utilisez des valeurs par défaut intelligentes (ex: 20h00, qui est souvent une bonne heure).
- **Bénéfice :** Le flux semble plus rapide et moins fragmenté. L'utilisateur a l'impression de tout configurer en un seul endroit, ce qui réduit la perception de l'effort.

#### Ajouter une Étape de Célébration
- **Observation actuelle :** Après la configuration, l'utilisateur arrive sur le tableau de bord, qui peut sembler un peu vide au début.
- **Conseil :** Juste avant d'afficher le tableau de bord pour la première fois, insérez un écran de félicitations et de confirmation. Un message simple et puissant comme : "C'est parti ! Votre plan d'épargne est activé. Votre premier prélèvement de 1000 FCFA aura lieu ce soir. Vous êtes sur la bonne voie pour acheter votre scooter !". Vous pouvez même y ajouter une animation Lottie pour un effet "wow".
- **Bénéfice :** Cela termine le parcours d'accueil sur une note extrêmement positive, renforce la décision de l'utilisateur, et gère ses attentes en lui confirmant ce qui va se passer ensuite.

---

### PLAN D'ACTION VALIDÉ POUR LA REFONTE DU FLUX

**Principe Directeur :** Développer le nouveau flux en parallèle de l'existant pour ne pas casser l'application. Créer de nouveaux écrans (ex: `GoalSelectionScreen.js`), les rendre dynamiques, les tester, puis les substituer à l'ancien flux.

**Phase 1 : Création des Nouveaux Écrans (Statiques)**

1.  **Créer `GoalSelectionScreen.js` :**
    *   **Action :** Créer un fichier `frontend/src/screens/savings/GoalSelectionScreen.js`.
    *   **Contenu :** Développer l'interface statique basée sur la maquette `maqDefGoal.html` et la capture d'écran de référence. L'écran doit présenter une liste d'objectifs cliquables.

2.  **Créer `SpeedSelectionScreen.js` :**
    *   **Action :** Créer un fichier `frontend/src/screens/savings/SpeedSelectionScreen.js`.
    *   **Contenu :** Développer une interface qui affiche l'objectif choisi, propose 3 options de vitesse (montant), et intègre sur la même page les champs pour l'heure et le portefeuille Mobile Money.

3.  **Créer `ConfirmationScreen.js` :**
    *   **Action :** Créer un fichier `frontend/src/screens/savings/ConfirmationScreen.js`.
    *   **Contenu :** Développer un écran de félicitations avec un résumé du plan d'épargne et un bouton de redirection vers le tableau de bord.

**Phase 2 : Intégration et Logique**

4.  **Rendre `GoalSelectionScreen.js` Dynamique :**
    *   **Action :** Ajouter la gestion de l'état (`useState`) pour la sélection. Modifier le slice Redux `savingsConfigSlice` pour y ajouter un champ `goal`. Connecter le bouton "Suivant" pour sauvegarder l'objectif et naviguer vers l'écran suivant.

5.  **Rendre `SpeedSelectionScreen.js` Dynamique :**
    *   **Action :** Connecter la logique de sélection de montant, l'heure et le portefeuille. Connecter le bouton "Activer" à l'action `saveSavingsConfig`. Naviguer vers l'écran de confirmation en cas de succès.

**Phase 3 : Finalisation et Remplacement**

6.  **Connecter `ConfirmationScreen.js` :**
    *   **Action :** Implémenter la navigation vers le `Dashboard`.

7.  **Modifier `InitialRouteResolver.js` :**
    *   **Action :** Mettre à jour la redirection pour que les nouveaux utilisateurs soient dirigés vers `GoalSelectionScreen`.

8.  **Nettoyage Final :**
    *   **Action :** Une fois le nouveau flux entièrement validé, supprimer les anciens écrans (`AmountSelectionScreen.js`, `FinalConfigScreen.js`) et nettoyer les routes dans `AppNavigator.js`.

**État Actuel (Point de reprise pour le prochain agent) :**
- Un bug critique a été corrigé : la déconnexion d'un utilisateur vide désormais l'état de la configuration d'épargne, garantissant que le flux pour un nouvel utilisateur démarre correctement. Le code a été sauvegardé sur Git.
- Le plan d'action pour la refonte du flux d'accueil a été validé.
- **Prochaine étape :** Commencer l'implémentation de la **Phase 1** du plan d'action : Créer l'écran statique `GoalSelectionScreen.js` (Phase 1, Étape 1 du plan ci-dessus).

---

### **[SESSION DU 24/06 - REPRISE]** GESTION DU PROFIL & STABILISATION

- **Contexte :** Cette session a été consacrée à la finalisation de la gestion du profil utilisateur et à la résolution de bugs d'instabilité persistants.

- **CODE PRÊT (Validé & Fonctionnel) :**
  1.  **Architecture Stable :** Le duo APK de développement + Backend sur Render est 100% fonctionnel.
  2.  **Gestion du Profil Utilisateur (TERMINÉE) :**
      - La modification du **nom** est fonctionnelle et le changement est correctement synchronisé sur le `Dashboard`.
      - Le changement de **PIN** est fonctionnel, avec un retour visuel (indicateur de chargement) pour une meilleure expérience utilisateur.
  3.  **Préparation à l'Upload d'Avatar (TERMINÉE) :**
      - **Frontend :** La librairie `expo-image-picker` est installée. La logique pour sélectionner une image depuis la galerie du téléphone est implémentée.
      - **Backend :** Le serveur est entièrement prêt à recevoir des images. `multer` est configuré, la route `PUT /api/users/me/avatar` est créée, et la logique de sauvegarde de l'image est en place.
  4.  **Bugs Stoppeurs Résolus :**
      - Le bug de la redirection vers l'inscription après un échec de connexion a été identifié (erreur 429 "Too Many Requests" du limiteur de débit) et le message d'erreur a été rendu plus clair pour l'utilisateur.
      - Les problèmes de "disparition" du bug étaient dus au caractère intermittent du rate limiting.

- **ÉTAT ACTUEL DU DÉVELOPPEMENT (Point de reprise) :**
  - **Objectif en cours :** Finaliser la fonctionnalité d'upload et d'affichage de la photo de profil.
  - **Dernier Point d'Attention :**
    - Nous avons découvert que le **déploiement automatique sur Render ne fonctionnait pas** car le filtre "Included Paths" était vide. Nous avons lancé un déploiement manuel du backend.
    - Nous avons également lancé un **nouveau build du frontend (`eas build`)** pour inclure la nouvelle dépendance native `expo-image-picker`. Ces deux processus doivent se terminer.
  - **PROCHAINE ACTION À LA REPRISE :**
    1.  **Vérifier** que le déploiement manuel du backend sur Render est bien terminé avec le statut "Live".
    2.  **Installer** le nouvel APK généré par `eas build` sur le téléphone de test.
    3.  **Tester de bout en bout la fonctionnalité d'avatar :**
        - Cliquer sur l'avatar dans le profil.
        - Choisir une image dans la galerie.
        - Confirmer que l'image s'affiche correctement dans le profil après l'upload.

---

### **[SESSION DU 24/06 - SOIR]** CORRECTION DU BUG D'UPLOAD D'AVATAR

- **Contexte :** La session a débuté par un test de la fonctionnalité d'upload de photo de profil. Le test a échoué avec une erreur "Échec de la mise à jour de l'avatar", indiquant que le frontend ne parvenait pas à envoyer l'image sélectionnée au backend.

- **DIAGNOSTIC & RÉSOLUTION :**
  1.  **Analyse Initiale :** L'examen du code a révélé que le backend tentait de sauvegarder les images sur le disque local du serveur (`multer.diskStorage`). Cette méthode est incompatible avec l'environnement de déploiement de Render, dont le système de fichiers est éphémère et non accessible publiquement.
  2.  **Solution d'Architecture :** La stratégie a été changée pour utiliser un service de stockage d'objets cloud. **Cloudinary** a été choisi pour sa fiabilité et son plan gratuit.
  3.  **Implémentation Backend :**
      - Les dépendances `cloudinary` et `datauri` ont été ajoutées au projet.
      - Le middleware `multer` a été reconfiguré pour utiliser le stockage en mémoire (`multer.memoryStorage`).
      - Le contrôleur `updateUserAvatar` a été entièrement réécrit pour :
          - Recevoir le fichier en mémoire.
          - Le formater en `base64`.
          - L'envoyer de manière sécurisée à l'API de Cloudinary.
          - Sauvegarder l'URL permanente renvoyée par Cloudinary dans la base de données de l'utilisateur.
  4.  **Débogage du Déploiement :**
      - Un premier déploiement a échoué car la dépendance `express-async-handler` était utilisée mais non déclarée dans `package.json`.
      - Une seconde erreur a été corrigée concernant l'utilisation du paquet `datauri`.
      - Ces deux problèmes ont été résolus, et les dépendances ont été correctement installées et configurées.

- **ÉTAT ACTUEL DU DÉVELOPPEMENT (Point de reprise) :**
  - **CODE PRÊT (Validé & Déployé) :**
    - Le backend a été **déployé avec succès sur Render** avec la nouvelle logique d'upload d'images via Cloudinary.
    - Les clés API de Cloudinary ont été ajoutées aux variables d'environnement sur Render.
    - La fonctionnalité d'upload est maintenant techniquement robuste et prête pour la production.
  - **PROCHAINE ACTION À LA REPRISE :**
    1.  **Effectuer le test de validation final** de la fonctionnalité d'upload d'avatar par l'utilisateur pour confirmer que l'ensemble du flux (Sélection -> Upload -> Affichage) fonctionne comme attendu.
    2.  Une fois validé, passer à la prochaine tâche définie dans le plan de projet.

---

### **[SESSION DU 25/06 - MATIN]** STABILISATION DE L'ÉCRAN PROFIL

- **Contexte :** La session a démarré avec un bug persistant où l'écran de profil "crashait" en affichant une ancienne erreur liée à l'échec de l'upload d'avatar, empêchant le chargement des données de l'utilisateur.

- **DIAGNOSTIC & RÉSOLUTION :**
  1.  **Analyse (Méthode des Logs Numérotés) :** L'application de notre méthode de débogage a révélé que l'état Redux du `userSlice` n'était pas réinitialisé après un échec. Une erreur précédente (ex: échec de l'upload) "polluait" l'état, provoquant un rendu incorrect et un crash au chargement suivant de l'écran.
  2.  **Solution d'Architecture :** Pour résoudre ce problème de "pollution d'état", une action de nettoyage a été implémentée.
      - **Backend :** Aucune modification nécessaire. Les investigations ont montré que les commits récents avaient déjà stabilisé le backend (gestion des erreurs, réponse de l'API, etc.).
      - **Frontend :**
          - Une nouvelle action `clearUserError` a été ajoutée au `userSlice` pour permettre de réinitialiser le statut et l'erreur à leur état initial (`idle`, `null`).
          - L'écran `ProfileScreen.js` a été mis à jour pour appeler cette action `clearUserError` à chaque fois qu'il est chargé (`useEffect`).
          - Cette correction garantit que l'écran tente toujours un chargement propre des données, quel que soit le résultat des actions précédentes.

- **ÉTAT ACTUEL DU DÉVELOPPEMENT (Point de reprise) :**
  - **CODE PRÊT (Validé & Stabilisé) :**
    - L'écran de profil est maintenant stable et ne crashe plus à cause d'erreurs persistantes.
    - La fonctionnalité de changement d'avatar est maintenant pleinement testable de bout en bout.
  - **PROCHAINE ACTION À LA REPRISE :**
    1.  Valider définitivement la fonctionnalité d'upload d'avatar en conditions réelles.
    2.  Consulter le plan (`task-master next`) pour identifier et démarrer la prochaine fonctionnalité prioritaire.

---

### NOUVELLE FONCTIONNALITÉ EN PLANIFICATION : GESTION DU PROFIL ET PARAMÈTRES

- **Objectif Stratégique :** Donner à l'utilisateur le contrôle sur son compte, lui permettre de personnaliser ses informations et de gérer ses paramètres de sécurité, renforçant ainsi la confiance et l'engagement à long terme.

- **Plan d'Action Détaillé :**

  - **Phase 1 : Backend & API (Le Socle)**
    1.  **Améliorer `GET /api/auth/me` :** S'assurer que cet endpoint (dans `authController.js`) renvoie toutes les informations utilisateur nécessaires (nom, prénom si ajoutés, etc.).
    2.  **Créer `PUT /api/users/me` :** Créer un nouvel endpoint et un contrôleur (`userController.js`) pour permettre la mise à jour des informations de l'utilisateur (ex: `fullName`).
    3.  **Créer `PUT /api/auth/change-pin` :** Créer un endpoint sécurisé dans `authController.js` qui demande l'ancien PIN et le nouveau pour le changement.

  - **Phase 2 : Frontend - Écrans Statiques (L'Interface)**
    1.  **Créer `frontend/src/screens/user/ProfileScreen.js` :**
        - Affichera un avatar par défaut, le nom de l'utilisateur, et le numéro de téléphone.
        - Contiendra une liste (`FlatList`) d'options : "Modifier le profil", "Sécurité", "Notifications", "Aide", "Se déconnecter".
    2.  **Créer `frontend/src/screens/user/SettingsScreen.js` :**
        - Accessible depuis le `ProfileScreen`.
        - Contiendra les options détaillées comme "Changer mon code PIN".

  - **Phase 3 : Frontend - Logique & State (Le Cerveau)**
    1.  **Créer `frontend/src/store/slices/userSlice.js` :**
        - Gérera l'état des informations du profil (`userInfo`).
        - Contiendra les thunks `fetchUserProfile`, `updateUserProfile`, et `changeUserPin`.
    2.  **Connecter `ProfileScreen.js` :** Le faire appeler `fetchUserProfile` au chargement pour afficher les données à jour.
    3.  **Implémenter la modification :** Utiliser des modaux pour la modification du nom et le changement de PIN afin de fournir une UX fluide.

  - **Phase 4 : Intégration & Navigation (Le Câblage)**
    1.  **Connecter le `DashboardScreen.js` :** Le bouton "Paramètres" (⚙️) naviguera vers le `ProfileScreen`.
    2.  **Mettre à jour `AppNavigator.js` :** Ajouter les nouvelles routes pour `ProfileScreen` et `SettingsScreen`.

- **Point de Reprise pour la Prochaine Session :**
  - **Action :** Commencer par la **Phase 1, Étape 1** : Améliorer l'endpoint `GET /api/auth/me` pour s'assurer qu'il renvoie un objet utilisateur complet et non juste le numéro de téléphone.

- **Implémentation de la Base pour le Profil Utilisateur (Session Actuelle) :**
  - **Backend (Phase 1 Terminée et Validée) :**
    - Amélioration de l'endpoint `GET /api/auth/me` pour qu'il s'appuie sur un modèle utilisateur enrichi.
    - Création de l'endpoint sécurisé `PUT /api/users/me` pour permettre la mise à jour du nom de l'utilisateur. La logique se trouve dans `backend/controllers/userController.js` et la route dans `backend/routes/user.js`.
    - Création de l'endpoint sécurisé `PUT /api/auth/change-pin` pour le changement de PIN. La logique est dans `authController.js` et la route dans `auth.js`.
    - Le modèle `User.js` a été mis à jour pour inclure le champ `fullName`.
    - **Validation :** Tous ces endpoints ont été testés avec succès via des requêtes `curl`/`Invoke-WebRequest`, confirmant leur bon fonctionnement.
  - **Frontend (Phase 2 & 3 en cours) :**
    - Création de l'écran statique `ProfileScreen.js` (dans `frontend/src/screens/user/`) basé sur la maquette `maqProfUser.html`.
    - Création d'un écran placeholder `SettingsScreen.js`.
    - Mise en place du `userSlice.js` dans le store Redux pour gérer l'état du profil, avec un thunk `fetchUserProfile` pour appeler l'API.
    - L'écran `ProfileScreen.js` est maintenant connecté au store et tente de récupérer les données au chargement.
    - La navigation a été ajoutée dans `AppNavigator.js` et le `DashboardScreen.js` a été mis à jour pour inclure un lien vers le profil.