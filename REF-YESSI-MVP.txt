# DOCUMENT DE RÉFÉRENCE - DÉVELOPPEMENT MVP YESSI-YESSI
# Mis à jour le: 16/06/2025

---

### STACK TECHNIQUE
- **Frontend :** React Native (Expo SDK 51+), Redux Toolkit, React Navigation, Axios.
- **Backend :** Node.js, Express.js, Mongoose, JWT, bcryptjs, `node-cron`.
- **Base de données :** MongoDB (via MongoDB Atlas).
- **Sécurité :** `helmet`, `express-rate-limit`, validation des entrées.

---

### DOCUMENTATION DES API

#### API Endpoint: `POST /api/auth/register`
- **Description:** Enregistre un nouvel utilisateur et envoie un code OTP (simulé).
- **Fichier Contrôleur:** `backend/controllers/authController.js` (fonction `registerUser`)
- **Protection:** Publique, avec limitation de débit.
- **Corps de la requête :**
  ```json
  { "fullName": "John Doe", "phoneNumber": "061234567", "pin": "1234" }
  ```
- **Réponse (Succès - 201 Created):** `{"success": true, "message": "Utilisateur enregistré..."}`
- **Réponses (Erreur):** `400` (Données invalides, utilisateur existant), `500` (Erreur serveur).

#### API Endpoint: `POST /api/auth/verify-otp`
- **Description:** Vérifie un code OTP pour finaliser l'inscription et renvoie un token JWT.
- **Fichier Contrôleur:** `backend/controllers/authController.js` (fonction `verifyOtp`)
- **Protection:** Publique.
- **Corps de la requête :**
  ```json
  { "phoneNumber": "061234567", "otpCode": "987654" }
  ```
- **Réponse (Succès - 200 OK):** `{"success": true, "token": "[JWT_TOKEN]"}`
- **Réponses (Erreur):** `400` (Utilisateur non trouvé, OTP invalide/expiré).

#### API Endpoint: `POST /api/auth/login`
- **Description:** Connecte un utilisateur existant et renvoie un token JWT.
- **Fichier Contrôleur:** `backend/controllers/authController.js` (fonction `loginUser`)
- **Protection:** Publique, avec limitation de débit.
- **Corps de la requête :**
  ```json
  { "phoneNumber": "061234567", "pin": "1234" }
  ```
- **Réponse (Succès - 200 OK):** `{"success": true, "token": "[JWT_TOKEN]"}`
- **Réponses (Erreur):** `400` (Identifiants incorrects, utilisateur non trouvé).

---

### FONCTIONNALITÉS IMPLÉMENTÉES (Refonte Majeure)

- **Refonte Complète du Flux d'Accueil :**
  - L'ancien parcours a été remplacé par un flux plus psychologique et intuitif : `GoalSelectionScreen` -> `SpeedSelectionScreen` -> `ConfirmationScreen`.
  - **`GoalSelectionScreen` :**
    - Permet à l'utilisateur de choisir un objectif prédéfini parmi une grille visuelle ou de créer le sien.
    - Utilise un modal (`CustomGoalModal`) pour la création/modification d'objectifs personnalisés (nom + montant).
    - Logique de navigation intelligente qui gère le retour au `Dashboard` pour un utilisateur existant.
  - **`SpeedSelectionScreen` :**
    - Récupère l'objectif choisi et affiche un récapitulatif.
    - Propose des "vitesses" d'épargne claires et permet la saisie d'un montant personnalisé via un modal (`CustomAmountModal`).
    - Intègre des composants réutilisables (`TimeSelector`, `MobileMoneySelector`) pour une expérience cohérente.
    - Affiche un récapitulatif complet et dynamique (incluant le temps estimé pour atteindre l'objectif).
    - Implémente un feedback de chargement clair sur le bouton d'activation.
  - **`ConfirmationScreen` :**
    - Célèbre la fin de la configuration avec une animation Lottie.

- **Synchronisation Backend/Frontend :**
  - Le modèle de données `SavingsConfig` a été mis à jour pour inclure la nouvelle structure (`goal` et `dailyAmount`).
  - Le `savingsController` a été corrigé pour sauvegarder et renvoyer les bonnes données.
  - Le calcul du `streak` (série de jours) est maintenant implémenté côté backend.

- **Amélioration du `DashboardScreen` :**
  - Affiche désormais correctement le nom de l'objectif, son montant, et l'épargne quotidienne.
  - Le calcul de la barre de progression est synchronisé avec l'objectif réel de l'utilisateur.
  - Le bouton "Modifier" ouvre un modal pour un changement rapide de la vitesse d'épargne, avec un lien pour modifier l'objectif.
  - La section "Prochain palier" est maintenant dynamique.

- **Nettoyage du Code :**
  - Les anciens écrans (`AmountSelectionScreen.js`, `FinalConfigScreen.js`) ont été supprimés.
  - Le navigateur (`AppNavigator.js`) a été nettoyé.

---

### ÉTAT ACTUEL DU DÉVELOPPEMENT (Point de reprise)

- **Objectif Actuel :** Terminé. La refonte du flux d'accueil et la synchronisation du tableau de bord sont complètes.
- **Progrès Récents :**
  - Finalisation de l'ensemble du parcours de configuration de l'épargne.
  - Correction des bugs de synchronisation des données entre le frontend et le backend.
  - Amélioration de l'UX/UI avec des modaux, des feedbacks de chargement et des micro-textes plus clairs.
  - Création d'une nouvelle règle de design (`ClarityAndAccessibility.mdc`).
- **Point de Blocage / Difficulté :** Aucune. Le flux est stable et fonctionnel.
- **Prochaine Action :**
  1.  Passer à la prochaine fonctionnalité majeure du backlog (ex: la mise en pause de l'épargne, la gestion du profil utilisateur, ou le retrait des fonds).
  2.  Commencer un nouveau cycle en suivant le `WORKFLOW.md` : `task-master next`, planification, etc.

---

### DETTE TECHNIQUE ET ACTIONS POST-MVP

- **Nettoyage de l'Historique Git (Priorité Haute) :**
  - **Contexte :** Pour débloquer le développement, un push contenant le fichier `google-services.json` (et donc des clés secrètes) a été manuellement autorisé sur GitHub.
  - **Risque :** Le secret est maintenant présent dans l'historique du dépôt. Bien que le risque soit limité pour ce projet, c'est une mauvaise pratique de sécurité.
  - **Action Requise :** Après le MVP, il faudra suivre une procédure de nettoyage de l'historique (ex: avec `git filter-repo` ou `BFG Repo-Cleaner`) pour supprimer définitivement le fichier secret de tous les commits. Il faudra ensuite invalider et remplacer les clés compromises sur la console Google Firebase.

---

### NOTES DE DÉVELOPPEMENT : APPROCHE POUR LES NOTIFICATIONS (TÂCHE #9)

- **Objectif Stratégique :**
  1.  **Créer la confiance :** Confirmer que l'épargne a bien eu lieu.
  2.  **Motiver l'utilisateur :** Lui rappeler ses objectifs et célébrer ses succès.
  3.  **Rendre l'application vivante :** Maintenir une connexion avec l'utilisateur même quand l'application est fermée.

- **Approche Globale en 5 Phases :**
  - **Phase 1 : La Fondation (Côté Client) :** Obtenir la permission de l'utilisateur et son token de notification Expo.
  - **Phase 2 : La Machinerie (Côté Serveur) :** Créer la capacité technique d'envoyer une notification à un token spécifique.
  - **Phase 3 : La Première Notification (Test) :** Envoyer une notification de confirmation immédiate après une épargne manuelle réussie.
  - **Phase 4 : Les Notifications Programmées (CRON) :** Mettre en place les rappels et confirmations pour l'épargne automatique.
  - **Phase 5 : La Finition (Contrôle et Navigation) :** Permettre à l'utilisateur de gérer ses préférences de notification et implémenter le "deep linking".

---

### JOURNAL DES PROBLÈMES RÉSOLUS

- **Échec Silencieux de l'Inscription/Connexion :** Un débogage approfondi a révélé plusieurs problèmes en cascade :
  1.  **Cause Initiale :** Une mauvaise configuration de l'URL de l'API dans le code client (`192.168.1.81` au lieu de `192.168.1.74`).
  2.  **Cause Profonde :** Un bug dans le `authSlice` de Redux où les reducers `setLoading` et `setError` n'étaient pas définis, provoquant un gel de l'application au moment du `dispatch`.
- **`ERR_NETWORK` au Login :** Ce problème était un "faux positif" causé par le gel de l'application dû au bug Redux. La connectivité réseau était en réalité fonctionnelle. Il a été définitivement résolu en corrigeant l'adresse IP de l'API dans `frontend/src/api/config.js`.
- **Instabilité du Serveur Backend :** La tâche CRON s'exécutait toutes les minutes et entrait en conflit avec les requêtes de l'API, bloquant le processus Node.js. **Solution :** Les tâches CRON sont maintenant désactivées en mode développement.
- **Avertissement `VirtualizedLists` sur le Dashboard :** Le `ScrollView` a été remplacé par une `FlatList` avec un `ListHeaderComponent` pour une performance et une structure optimales.
- **Erreur `Unable to resolve module react-native-svg` :** Un problème persistant qui a résisté aux méthodes de nettoyage de cache classiques.
  1.  **Hypothèse Initiale (Incorrecte) :** Problème de cache de Metro Bundler ou de `npm`.
  2.  **Cause Réelle :** Installation d'une version de `react-native-svg` incompatible avec le SDK Expo du projet, due à l'utilisation de `npm install` au lieu de la commande propriétaire d'Expo.
  3.  **Solution Définitive :** Désinstallation de la librairie (`npm uninstall`) et réinstallation avec la commande correcte qui garantit la compatibilité : `npx expo install react-native-svg`.
- **Conflit de dépendances `react-native-svg` (Erreur "register two views") :**
  - **Symptôme :** L'application plante au démarrage avec une longue liste d'erreurs "Invariant Violation: Tried to register two views with the same name RNSVG...".
  - **Cause :** La librairie `react-native-svg` est initialisée deux fois, créant un conflit. Cela se produit souvent à cause de versions conflictuelles des dépendances dans `node_modules`.
  - **Solution (Robuste) :** Effectuer un nettoyage complet de l'environnement de développement.
    1.  Fermer tous les terminaux et éditeurs de code.
    2.  Supprimer manuellement les dossiers `node_modules` à la racine du projet et dans le dossier `frontend`. (Sur Windows, si l'accès est refusé, un redémarrage de l'ordinateur peut être nécessaire pour libérer les fichiers).
    3.  Exécuter `npm install` à la racine pour réinstaller proprement toutes les dépendances.
    4.  Lancer l'application avec `npx expo start -c` pour s'assurer que le cache est propre.
- **...et de nombreux autres problèmes de configuration et de logique résolus lors de cette session de débogage intensive.**
- **Logique de redirection des nouveaux utilisateurs :**
  - **Symptôme :** Les nouveaux utilisateurs étaient redirigés vers le `Dashboard` au lieu du flux de configuration de l'épargne.
  - **Cause :** La logique du composant `
  - **Cascade d'erreurs de compilation (Build Android) :** Une série de problèmes a empêché la compilation du "development build".
  1.  **Erreur `Default FirebaseApp is not initialized` :**
      - **Symptôme :** L'application plantait après la demande de permission de notification.
      - **Cause :** Le fichier `google-services.json` n'était pas inclus dans le build, car il manquait la référence dans la configuration Expo.
      - **Solution :** Ajout de la clé `"googleServicesFile": "./google-services.json"` dans la section `android` du fichier `app.json`.
  2.  **Erreur `The expo package was not found` :**
      - **Symptôme :** La commande `npx eas build` échouait systématiquement car elle ne trouvait pas l'exécutable `expo`.
      - **Cause :** Le projet contient deux `package.json` (un à la racine `YYB/` et un dans `frontend/`). Les commandes étaient lancées depuis la racine au lieu du dossier `frontend`, qui contient les bonnes dépendances.
      - **Solution :** Exécuter systématiquement toutes les commandes `npm` et `eas` depuis le dossier `frontend/`. Pour fiabiliser, un script `eas-build:dev` a été ajouté au `package.json` du frontend.
  3.  **Erreur Gradle `Missing project_info object` :**
      - **Symptôme :** La compilation sur les serveurs d'EAS échouait lors du traitement du fichier `google-services.json`.
      - **Cause :** Le fichier avait été téléversé via une méthode incorrecte et obsolète (`eas credentials` -> `FCM Legacy Key`), ce qui a corrompu son format.
      - **Solution :** La clé incorrecte a été supprimée. Le fichier `google-services.json` a été téléversé de manière sécurisée via la méthode moderne (`npx eas secret:create ... --type file`). Le fichier `eas.json` a été mis à jour pour lier ce secret à la variable d'environnement `GOOGLE_SERVICES_JSON` lors de la compilation.

---

### NOUVEAU FLUX D'ACCUEIL UTILISATEUR (À IMPLÉMENTER)

- **Contexte :** Le flux d'accueil initial (`Inscription -> Choix Montant -> Config Finale`) a été jugé peu engageant. Un nouveau flux, plus centré sur la motivation de l'utilisateur, a été validé et son implémentation a commencé.
- **Objectif :** Remplacer l'ancien flux par un parcours plus psychologique pour améliorer l'activation et la rétention des nouveaux utilisateurs.

- **Nouveau Flux Cible Validé :**
  `Inscription -> Choix Objectif -> Choix Vitesse (Montant) -> Config Finale (sur la même page) -> Célébration -> Dashboard`

---

### PRINCIPES CLÉS DE LA REFONTE

#### Fluidifier la Configuration Finale
- **Observation actuelle :** L'utilisateur passe de `AmountSelectionScreen` à `FinalConfigScreen`, ce qui crée une étape supplémentaire.
- **Conseil :** Une fois le montant sélectionné, au lieu de naviguer vers un nouvel écran, faites apparaître les deux dernières questions directement en dessous sur la même page : "À quelle heure ?" et "Quel portefeuille ?". Utilisez des valeurs par défaut intelligentes (ex: 20h00, qui est souvent une bonne heure).
- **Bénéfice :** Le flux semble plus rapide et moins fragmenté. L'utilisateur a l'impression de tout configurer en un seul endroit, ce qui réduit la perception de l'effort.

#### Ajouter une Étape de Célébration
- **Observation actuelle :** Après la configuration, l'utilisateur arrive sur le tableau de bord, qui peut sembler un peu vide au début.
- **Conseil :** Juste avant d'afficher le tableau de bord pour la première fois, insérez un écran de félicitations et de confirmation. Un message simple et puissant comme : "C'est parti ! Votre plan d'épargne est activé. Votre premier prélèvement de 1000 FCFA aura lieu ce soir. Vous êtes sur la bonne voie pour acheter votre scooter !". Vous pouvez même y ajouter une animation Lottie pour un effet "wow".
- **Bénéfice :** Cela termine le parcours d'accueil sur une note extrêmement positive, renforce la décision de l'utilisateur, et gère ses attentes en lui confirmant ce qui va se passer ensuite.

---

### PLAN D'ACTION VALIDÉ POUR LA REFONTE DU FLUX

**Principe Directeur :** Développer le nouveau flux en parallèle de l'existant pour ne pas casser l'application. Créer de nouveaux écrans (ex: `GoalSelectionScreen.js`), les rendre dynamiques, les tester, puis les substituer à l'ancien flux.

**Phase 1 : Création des Nouveaux Écrans (Statiques)**

1.  **Créer `GoalSelectionScreen.js` :**
    *   **Action :** Créer un fichier `frontend/src/screens/savings/GoalSelectionScreen.js`.
    *   **Contenu :** Développer l'interface statique basée sur la maquette `maqDefGoal.html` et la capture d'écran de référence. L'écran doit présenter une liste d'objectifs cliquables.

2.  **Créer `SpeedSelectionScreen.js` :**
    *   **Action :** Créer un fichier `frontend/src/screens/savings/SpeedSelectionScreen.js`.
    *   **Contenu :** Développer une interface qui affiche l'objectif choisi, propose 3 options de vitesse (montant), et intègre sur la même page les champs pour l'heure et le portefeuille Mobile Money.

3.  **Créer `ConfirmationScreen.js` :**
    *   **Action :** Créer un fichier `frontend/src/screens/savings/ConfirmationScreen.js`.
    *   **Contenu :** Développer un écran de félicitations avec un résumé du plan d'épargne et un bouton de redirection vers le tableau de bord.

**Phase 2 : Intégration et Logique**

4.  **Rendre `GoalSelectionScreen.js` Dynamique :**
    *   **Action :** Ajouter la gestion de l'état (`useState`) pour la sélection. Modifier le slice Redux `savingsConfigSlice` pour y ajouter un champ `goal`. Connecter le bouton "Suivant" pour sauvegarder l'objectif et naviguer vers l'écran suivant.

5.  **Rendre `SpeedSelectionScreen.js` Dynamique :**
    *   **Action :** Connecter la logique de sélection de montant, l'heure et le portefeuille. Connecter le bouton "Activer" à l'action `saveSavingsConfig`. Naviguer vers l'écran de confirmation en cas de succès.

**Phase 3 : Finalisation et Remplacement**

6.  **Connecter `ConfirmationScreen.js` :**
    *   **Action :** Implémenter la navigation vers le `Dashboard`.

7.  **Modifier `InitialRouteResolver.js` :**
    *   **Action :** Mettre à jour la redirection pour que les nouveaux utilisateurs soient dirigés vers `GoalSelectionScreen`.

8.  **Nettoyage Final :**
    *   **Action :** Une fois le nouveau flux entièrement validé, supprimer les anciens écrans (`AmountSelectionScreen.js`, `FinalConfigScreen.js`) et nettoyer les routes dans `AppNavigator.js`.

**État Actuel (Point de reprise pour le prochain agent) :**
- Un bug critique a été corrigé : la déconnexion d'un utilisateur vide désormais l'état de la configuration d'épargne, garantissant que le flux pour un nouvel utilisateur démarre correctement. Le code a été sauvegardé sur Git.
- Le plan d'action pour la refonte du flux d'accueil a été validé.
- **Prochaine étape :** Commencer l'implémentation de la **Phase 1** du plan d'action : Créer l'écran statique `GoalSelectionScreen.js` (Phase 1, Étape 1 du plan ci-dessus).