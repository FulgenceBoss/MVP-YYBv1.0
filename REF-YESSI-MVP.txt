# DOCUMENT DE RÉFÉRENCE - DÉVELOPPEMENT MVP YESSI-YESSI
# Mis à jour le: 16/06/2025

---

### STACK TECHNIQUE
- **Frontend :** React Native (Expo SDK 51+), Redux Toolkit, React Navigation, Axios.
- **Backend :** Node.js, Express.js, Mongoose, JWT, bcryptjs, `node-cron`.
- **Base de données :** MongoDB (via MongoDB Atlas).
- **Sécurité :** `helmet`, `express-rate-limit`, validation des entrées.

---

### DOCUMENTATION DES API

#### API Endpoint: `POST /api/auth/register`
- **Description:** Enregistre un nouvel utilisateur et envoie un code OTP (simulé).
- **Fichier Contrôleur:** `backend/controllers/authController.js` (fonction `registerUser`)
- **Protection:** Publique, avec limitation de débit.
- **Corps de la requête :**
  ```json
  { "fullName": "John Doe", "phoneNumber": "061234567", "pin": "1234" }
  ```
- **Réponse (Succès - 201 Created):** `{"success": true, "message": "Utilisateur enregistré..."}`
- **Réponses (Erreur):** `400` (Données invalides, utilisateur existant), `500` (Erreur serveur).

#### API Endpoint: `POST /api/auth/verify-otp`
- **Description:** Vérifie un code OTP pour finaliser l'inscription et renvoie un token JWT.
- **Fichier Contrôleur:** `backend/controllers/authController.js` (fonction `verifyOtp`)
- **Protection:** Publique.
- **Corps de la requête :**
  ```json
  { "phoneNumber": "061234567", "otpCode": "987654" }
  ```
- **Réponse (Succès - 200 OK):** `{"success": true, "token": "[JWT_TOKEN]"}`
- **Réponses (Erreur):** `400` (Utilisateur non trouvé, OTP invalide/expiré).

#### API Endpoint: `POST /api/auth/login`
- **Description:** Connecte un utilisateur existant et renvoie un token JWT.
- **Fichier Contrôleur:** `backend/controllers/authController.js` (fonction `loginUser`)
- **Protection:** Publique, avec limitation de débit.
- **Corps de la requête :**
  ```json
  { "phoneNumber": "061234567", "pin": "1234" }
  ```
- **Réponse (Succès - 200 OK):** `{"success": true, "token": "[JWT_TOKEN]"}`
- **Réponses (Erreur):** `400` (Identifiants incorrects, utilisateur non trouvé).

---

### FONCTIONNALITÉS IMPLÉMENTÉES

- **Flux d'authentification complet :**
  - Écrans `SignUpScreen`, `OtpScreen`, et `LoginScreen` 100% fonctionnels et robustes.
  - Logique de redirection post-authentification via Redux et `AppNavigator`.
- **Flux de configuration de l'épargne :**
  - Écrans `AmountSelectionScreen` et `FinalConfigScreen` fonctionnels.
  - Sauvegarde de la configuration via des mises à jour partielles au backend.
- **Processeur d'Épargne Automatisé (Backend) :**
  - Le service CRON (`cronService.js`) est implémenté mais **désactivé en développement** pour garantir la stabilité du serveur.
- **Tableau de Bord :**
  - Le `DashboardScreen` a été refactorisé pour corriger l'avertissement `VirtualizedLists` et affiche le solde et l'historique de l'utilisateur.
  - Le composant `StreakCounter` est intégré.
  - Intégration des librairies `react-native-svg` et `expo-linear-gradient` pour un design avancé.
- **Historique des transactions :**
  - L'affichage de l'historique des transactions est désormais validé et fonctionnel.
- **Navigation Intelligente :**
  - Un écran `AppLoadingScreen` vérifie la configuration et redirige correctement.
- **Configuration API Robuste :**
  - L'URL de l'API est maintenant gérée dans un fichier de configuration dédié, non suivi par Git.
- **Écran d'historique dédié (Nouveau) :**
  - Un nouvel écran `HistoryScreen.js` a été créé pour afficher l'historique détaillé.
  - L'interface a été implémentée statiquement en se basant sur la maquette `maqHisto.html` et est visuellement validée.
  - La navigation vers cet écran depuis le tableau de bord est fonctionnelle.
- **Épargne Manuelle (Nouveau) :**
  - Le flux complet d'épargne manuelle est désormais implémenté et validé.
  - L'expérience utilisateur a été améliorée avec un écran de statut de transaction dédié utilisant des animations Lottie pour les états de succès, d'échec et de chargement.
  - La gestion des erreurs réseau a été renforcée pour fournir des messages clairs à l'utilisateur.
  - Amélioration de l'UX/UI sur la sélection de l'opérateur et la saisie du numéro.
- **Refonte de l'Écran de Configuration (Nouveau) :**
  - L'écran de configuration finale de l'épargne (`FinalConfigScreen`) a été entièrement refondu pour correspondre à la maquette de haute-fidélité.
  - Implémentation d'un slider personnalisé et interactif pour la sélection de l'heure.
  - Amélioration de l'UX/UI sur la sélection de l'opérateur et la saisie du numéro.

---

### NOTE TECHNIQUE : Approche de Filtrage des Transactions

- **Problématique :** Le filtrage des transactions ("7 jours", "30 jours") doit fonctionner de manière fiable pendant le développement, même avec des données de test qui ne sont pas à jour (ex: transactions datées de 2025 alors que nous sommes en 2024).
- **Approche Actuelle (pour le Développement) :** La logique de filtrage utilise la **date de la transaction la plus récente** comme point de référence pour "aujourd'hui". Cela garantit que les filtres sont fonctionnels et testables visuellement, peu importe l'âge des données.
- **Action Requise Avant Production :** Avant le déploiement final, cette logique devra être remplacée par une approche standard qui se base sur la **date réelle du jour**. Le code devra être modifié pour comparer les dates de transaction à `new Date()`. Cette modification ne pourra être validée qu'avec des données de transactions réelles ou à jour.

---

### ÉTAT ACTUEL DU DÉVELOPPEMENT (Point de reprise)

- **Objectif Actuel :** Refonte de l'interface utilisateur (UI) du parcours d'authentification pour une expérience utilisateur améliorée.
- **Progrès Récents :**
  - Le système de notifications push a été implémenté et validé de bout en bout (sauvegarde du token, notifications manuelles et automatiques).
  - Le système de suivi analytique a été mis en place pour les événements clés du parcours utilisateur.
- **Point de Blocage / Difficulté :** Aucune. En attente de la reprise du développement.
- **Prochaine Action :**
  1.  Commencer le développement statique de la nouvelle version de l'écran d'inscription (`SignUpScreen`).
  2.  Poursuivre avec le développement statique de l'écran de validation OTP et de création de PIN (`OtpScreen`).
  3.  Intégrer progressivement ces nouvelles interfaces dans l'application existante.

---

### DETTE TECHNIQUE ET ACTIONS POST-MVP

- **Nettoyage de l'Historique Git (Priorité Haute) :**
  - **Contexte :** Pour débloquer le développement, un push contenant le fichier `google-services.json` (et donc des clés secrètes) a été manuellement autorisé sur GitHub.
  - **Risque :** Le secret est maintenant présent dans l'historique du dépôt. Bien que le risque soit limité pour ce projet, c'est une mauvaise pratique de sécurité.
  - **Action Requise :** Après le MVP, il faudra suivre une procédure de nettoyage de l'historique (ex: avec `git filter-repo` ou `BFG Repo-Cleaner`) pour supprimer définitivement le fichier secret de tous les commits. Il faudra ensuite invalider et remplacer les clés compromises sur la console Google Firebase.

---

### NOTES DE DÉVELOPPEMENT : APPROCHE POUR LES NOTIFICATIONS (TÂCHE #9)

- **Objectif Stratégique :**
  1.  **Créer la confiance :** Confirmer que l'épargne a bien eu lieu.
  2.  **Motiver l'utilisateur :** Lui rappeler ses objectifs et célébrer ses succès.
  3.  **Rendre l'application vivante :** Maintenir une connexion avec l'utilisateur même quand l'application est fermée.

- **Approche Globale en 5 Phases :**
  - **Phase 1 : La Fondation (Côté Client) :** Obtenir la permission de l'utilisateur et son token de notification Expo.
  - **Phase 2 : La Machinerie (Côté Serveur) :** Créer la capacité technique d'envoyer une notification à un token spécifique.
  - **Phase 3 : La Première Notification (Test) :** Envoyer une notification de confirmation immédiate après une épargne manuelle réussie.
  - **Phase 4 : Les Notifications Programmées (CRON) :** Mettre en place les rappels et confirmations pour l'épargne automatique.
  - **Phase 5 : La Finition (Contrôle et Navigation) :** Permettre à l'utilisateur de gérer ses préférences de notification et implémenter le "deep linking".

---

### JOURNAL DES PROBLÈMES RÉSOLUS

- **Échec Silencieux de l'Inscription/Connexion :** Un débogage approfondi a révélé plusieurs problèmes en cascade :
  1.  **Cause Initiale :** Une mauvaise configuration de l'URL de l'API dans le code client (`192.168.1.81` au lieu de `192.168.1.74`).
  2.  **Cause Profonde :** Un bug dans le `authSlice` de Redux où les reducers `setLoading` et `setError` n'étaient pas définis, provoquant un gel de l'application au moment du `dispatch`.
- **`ERR_NETWORK` au Login :** Ce problème était un "faux positif" causé par le gel de l'application dû au bug Redux. La connectivité réseau était en réalité fonctionnelle. Il a été définitivement résolu en corrigeant l'adresse IP de l'API dans `frontend/src/api/config.js`.
- **Instabilité du Serveur Backend :** La tâche CRON s'exécutait toutes les minutes et entrait en conflit avec les requêtes de l'API, bloquant le processus Node.js. **Solution :** Les tâches CRON sont maintenant désactivées en mode développement.
- **Avertissement `VirtualizedLists` sur le Dashboard :** Le `ScrollView` a été remplacé par une `FlatList` avec un `ListHeaderComponent` pour une performance et une structure optimales.
- **Erreur `Unable to resolve module react-native-svg` :** Un problème persistant qui a résisté aux méthodes de nettoyage de cache classiques.
  1.  **Hypothèse Initiale (Incorrecte) :** Problème de cache de Metro Bundler ou de `npm`.
  2.  **Cause Réelle :** Installation d'une version de `react-native-svg` incompatible avec le SDK Expo du projet, due à l'utilisation de `npm install` au lieu de la commande propriétaire d'Expo.
  3.  **Solution Définitive :** Désinstallation de la librairie (`npm uninstall`) et réinstallation avec la commande correcte qui garantit la compatibilité : `npx expo install react-native-svg`.
- **Conflit de dépendances `react-native-svg` (Erreur "register two views") :**
  - **Symptôme :** L'application plante au démarrage avec une longue liste d'erreurs "Invariant Violation: Tried to register two views with the same name RNSVG...".
  - **Cause :** La librairie `react-native-svg` est initialisée deux fois, créant un conflit. Cela se produit souvent à cause de versions conflictuelles des dépendances dans `node_modules`.
  - **Solution (Robuste) :** Effectuer un nettoyage complet de l'environnement de développement.
    1.  Fermer tous les terminaux et éditeurs de code.
    2.  Supprimer manuellement les dossiers `node_modules` à la racine du projet et dans le dossier `frontend`. (Sur Windows, si l'accès est refusé, un redémarrage de l'ordinateur peut être nécessaire pour libérer les fichiers).
    3.  Exécuter `npm install` à la racine pour réinstaller proprement toutes les dépendances.
    4.  Lancer l'application avec `npx expo start -c` pour s'assurer que le cache est propre.
- **...et de nombreux autres problèmes de configuration et de logique résolus lors de cette session de débogage intensive.**
- **Logique de redirection des nouveaux utilisateurs :**
  - **Symptôme :** Les nouveaux utilisateurs étaient redirigés vers le `Dashboard` au lieu du flux de configuration de l'épargne.
  - **Cause :** La logique du composant `
  - **Cascade d'erreurs de compilation (Build Android) :** Une série de problèmes a empêché la compilation du "development build".
  1.  **Erreur `Default FirebaseApp is not initialized` :**
      - **Symptôme :** L'application plantait après la demande de permission de notification.
      - **Cause :** Le fichier `google-services.json` n'était pas inclus dans le build, car il manquait la référence dans la configuration Expo.
      - **Solution :** Ajout de la clé `"googleServicesFile": "./google-services.json"` dans la section `android` du fichier `app.json`.
  2.  **Erreur `The expo package was not found` :**
      - **Symptôme :** La commande `npx eas build` échouait systématiquement car elle ne trouvait pas l'exécutable `expo`.
      - **Cause :** Le projet contient deux `package.json` (un à la racine `YYB/` et un dans `frontend/`). Les commandes étaient lancées depuis la racine au lieu du dossier `frontend`, qui contient les bonnes dépendances.
      - **Solution :** Exécuter systématiquement toutes les commandes `npm` et `eas` depuis le dossier `frontend/`. Pour fiabiliser, un script `eas-build:dev` a été ajouté au `package.json` du frontend.
  3.  **Erreur Gradle `Missing project_info object` :**
      - **Symptôme :** La compilation sur les serveurs d'EAS échouait lors du traitement du fichier `google-services.json`.
      - **Cause :** Le fichier avait été téléversé via une méthode incorrecte et obsolète (`eas credentials` -> `FCM Legacy Key`), ce qui a corrompu son format.
      - **Solution :** La clé incorrecte a été supprimée. Le fichier `google-services.json` a été téléversé de manière sécurisée via la méthode moderne (`npx eas secret:create ... --type file`). Le fichier `eas.json` a été mis à jour pour lier ce secret à la variable d'environnement `GOOGLE_SERVICES_JSON` lors de la compilation.